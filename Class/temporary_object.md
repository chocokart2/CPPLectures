# 임시 객체

## 임시 객체 예시)
```
int a = 3 + 5;
```
메모리는 a 뿐만 아니라 3과 5에도 메모리 4바이트를 할당받는다.
a는 함수가 끝날 때 까지는 계속 메모리에 로드되어 있지만
3과 5는 저 라인이 끝나는 즉시 소멸된다. 임시 객체는 이와 같다.

설명을 위해 메인 함수 위에다 Point 클래스를 정의한다.
```
class Point {
public:
	int x, y;
	Point(int a, int b) : x(a), y(b) { cout << "Point()" << endl; }
	~Point() { cout << "~Point()" << endl; }
	Point(const Point& p) { cout << "Copt Point()" << endl; }
};
```

## 임시 객체의 특징

1. 우리 눈에 보이지 않고 소스 코드에도 없다.

임시 객체는 컴파일러가 연산 과정에서 임시로 할당하는 메모리이다.

아래 코드는 일반 객체 p와 임시 객체를 생성한 것이다.
```
void main()
{
	Point p(1,4);	// 지역객체, 이름이 있고 {} 벗어날 때 파괴

	Point(3,7);	// 임시객체 생성, 이름이 없고 "문장 끝에서 파괴"된다
		            // C++ 표준문서에 공식 언급된 기법
}
```

2. 힙 이외의 공간에 생성되는 이름없는 객체이다.

임시 객체들은 단순히 참조할 수 없다. 아래 코드를 메인 함수 안에다 작성해보자.
```
Point& a = Point(4, 9); // error // 비 const 참조에 대한 초기 값은 lvalue여야 합니다.
```
다만 상수로 참조하거나 C++11 버전에서 임시객체를 가리키는 방법이 있다.

아래 코드를 메인함수 안에다 작성해보자.
```
Point&& r1 = Point(1, 2);
cout << "r1 : " << r1.x << ", " << r1.y << endl;
r1 = Point(3, 7);
cout << "r1 : " << r1.x << ", " << r1.y << endl;

cout << endl;

const Point& r2 = Point(10, 20);
//r2 = Point(3, 6); // error // 일치하는 피연산자 = 가 없음
cout << "r2 : " << r2.x << ", " << r2.y << endl;

return 0;
```
실행 결과
```
Point()
r1 : 1, 2
Point()
~Point()
r1 : 3, 7

Point()
r2 : 10, 20
~Point()
~Point()
```

3. 임시 객체는 rvalue에 속한다.

lvalue는 이름이 있는 object, rvalue는 이름이 없고 해당 값이 사용되는 expression을 넘어서는 생존하지 않음.
그리고 rvalue는 저장하는게 아닌 쓰고 버리는 느낌이라, 대입 연산자의 오른쪽에만 위치한다.
(반대로 lvalue는 대입 연산자의 오른쪽과 왼쪽에 모두 위치할 수 있다.)

(메인 함수 내부)
```
Point p(1,2);
p.x = 10; // ok

Point(1, 2).x = 10; // error : 식이 수정할 수 있는 lvalue여야 합니다.
```

4. 실행 도중 잠깐만 사용되는 객체이다.

문장의 끝에서 파괴되는 것도 있고, 그 임시 객체를 상수로 참조(&)하는 변수가 있으면 그 변수가 파괴될 때까지 살아 있게 할 수도 있다.

메인함수 안쪽에다가 아래의 코드를 적어보자. 임시 객체를 상수로 참조하는 변수롤 만들었다.
```
{
	cout << "이미 중괄호가 시작된 곳" << endl;
	const Point& a = Point(4, 9);
	cout << "중괄호가 끝나려는 곳" << endl;
}
cout << "중괄호 바깥" << endl;
```
해당 코드의 결과
```
이미 중괄호가 시작된 곳
Point()
중괄호가 끝나려는 곳
~Point()
중괄호 바깥
```

5. 성능저하를 불러일으키는 요인이 된다. (임시 객체의 생성과 소멸이라는 비용)

6. 임시 객체가 만들어지는 상황
* 함수 호출을 성사시키기 위해,
* 함수가 객체를 값으로 반환. 리턴 바이 벨류 (따라서 리턴 바이 레퍼런스를 추천함)


+리턴 바이 벨류, 리턴 바이 레퍼런스

리턴 바이 벨류는 값을 리턴하는 것이다.
int funcName() : 값 리턴 -> 리턴 값에 임시 객체가 생성되어 담기게 된다.

리턴 바이 레퍼런스는 참조를 리턴하는 것이다.
int& funcName() : 참조 리턴, 있던 값 리턴용 임시 객체를 만들지 말라는 의도


지역변수는 함수를 빠져나가는 순간 그 지역변수의 주소는 유효하지 않는 곳이 되므로 지역변수를 참조리턴하면 안 됨.
참조 매개 변수, 함수에 전달된 배열의 요소, 또는 함수의 끝에서 소멸하지 않는 구조체나 클래스를 참조로 반환 할 것.

+Lvalue와 Rvalue
Lvalue
* 대입 연산자에서는 좌변에 놓일 수도 있고, 우변에 놓일 수도 있다.
* 식별자를 가지고 있음.
* 수정할 수 있는 lvalue도 있고 수정 불가능한 lvalue도 존재한다(배열타입, 불완전한 타입, const 한정자가 붙은 타입은 수정할 수 없는 lvalue이다.)
* 사용하는 식 외에도 유효하다.

Rvalue
* 대입 연산자에서는 우변에만 놓인다.
* 데이터의 메모리를 복사할 공간이 없거나, 식별자가 따로 존재하지 않는다.
* 자신의 상태를 수정할 수 없다.
* rvalue를 사용하는 식에서만 유효함. 단 rvalue를 참조하는 변수가 있을 경우, 그 변수가 소멸할때까지 유효함

Lvalue 레퍼런스
메모리가 확실히 존재, 위치를 식별할 수 있는 변수들만 대입이 가능하다.
예)
int k = 10
int & lvalueRef = k;

Rvalue 레퍼런스
메모리의 위치를 특정할 수 없는 변수에 참조를 받을 수 있다.
예)
int && rvalueRef = 20;

Rvalue 값의 재사용이 필요한 경우, Rvalue 레퍼런스를 활용하면 된다.
이때, Rvalue는  Rvalue 레퍼런스가 파괴될때까지 유효해진다.
